崔 正行
05-151016

問1
私の所属の2班はPowerベースのアーキテクチャで、
関数の呼び出し規約はPowerPCと似ています。
全部Caller側でレジスタの保存と復元の作業をやります
まずはリンクレジスタをr31に退避してメモリに書き込んで、
サブルーチンに使うレジスタに入っている今の値をレジスタやメモリに退避して、
スタックレジスタの値を増やしてスタックを確保する。
サブルーチンでは結果をr2からの結果に保存して、
リンクレジスタの指す番地にジャンプします。
サブルーチンから戻ってきたらまずスタックを減らして、
一般レジスタの値を復元して、
元のリンクレジスタの値をメモリから呼んで復元されます。
よくあるパータンですが、
サブルーチン内の処理を行う時はとても楽ですが、
呼ばれる関数の実行命令数が少ない場合はオーバーヘッドがとても大きい欠点があります。
以降は、末尾再帰のような関数呼び出しをコンパイラで
全部Whileなどのようなループになおす予定です。

4班のアーキテクチャも似たようなCallerSaveになっていますが、
レジスタを明確に二種類に分けて、
親関数が退避して勝手に使っていいレジスタ群と、
親関数が退避して無いから使ったら元の値に戻さないといけないレジスタ群です。
サブルーチンの引数が少ないときとか
親関数は全部のレジスタを退避しなくてすむので、
少し高速化できます。

MIPSのgccに適用されている規約について調べました。
r4からr7まではサブルーチンに渡す引数に使います。
それ以上に引数があったらそれらをスタックに入れて渡します。
r1とr2にはサブルーチンの結果を格納します。
r8−r15, r24, r25はCallerがその値を退避して、Calleeが自由に使っていいです。
r16-24はCalleeがそれを使ったら、元の値に戻さないといけない。
r29はスタックポインタです。戻りアドレスをr31に入れます。
Calleeが自由に使っていいレジスタは4班のアーキテクチャより多くて、
関数呼び出されるときはオーバヘッド少し大きいですが、
すべてのレジスタを退避させるよりは効率的です。
