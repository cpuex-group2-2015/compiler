05151016
崔 正行

問1
let rec xf x0 =
 let x1 =
    let x2 = x0 - (-x0) in
      x2 – (let x3 = -x2 in x3 - (-x3))
  in
  x1 - (-x1) in
let xn = xf 125 in
xn - (- xn)

以下はK正規化の結果です。
let xf x0 =
  let x5 = -x0 in
  let x2 = x0 - x5 in
  let x3 = -x2 in
  let x6 = -x3 in
  let x4 = x3 - x6 in
  let x1 = x2 - x4 in
  let x7 = -x1 in
  x1 - x7 in
let xn = xf 125 in
let x8 = -xn in
xn - x8

以下はA正規化の結果です。
let x0 = 125 in
let x5 = -x0 in
let x2 = x0 - x5 in
let x3 = -x2 in
let x6 = -x3 in
let x4 = x3 - x6 in
let x1 = x2 - x4 in
let x7 = -x1 in
let xn = x1 - x7 in
let x8 = -xn in
xn - x8

結果はどれも以下です。
- : int = 3000

読みやすさのために、
どれも先にα変換を先にしてから正規化を行いました。

問2
kNormal.mlに以下のような関数を実装した。

let rec delete_duplication list e =
  match e with
  | Let((x, t), e1, e2) ->
    (try
       let r = Hashtbl.find list e1 in
       Let((x, t), Var(r), (delete_duplication list e2))
     with
     | _ ->
        Hashtbl.add list e1 x;
        Let((x, t), e1, (delete_duplication list e2)))
  | _ -> e

listはHashtableです。既に定義されたLetのペアを保存する。
Let以外の構造はそのまま返す。

let x = 1 in
let y = 1 in
let a = x + y in
let b = x + y in
print_int (a + b)
以上のサンプルのコードに対して、以下を出力しました。
=======================
KNormal
=======================
  LET x =
    INT 1
  IN
  LET y =
    INT 1
  IN
  LET a =
    ADD x y
  IN
  LET b =
    ADD x y
  IN
  LET Ti1 =
    ADD a b
  IN
  EXTFUNAPP print_int Ti1
=======================
Delete Duplication
=======================
  LET x =
    INT 1
  IN
  LET y =
    VAR x
  IN
  LET a =
    ADD x y
  IN
  LET b =
    VAR a
  IN
  LET Ti1 =
    ADD a b
  IN
  EXTFUNAPP print_int Ti1

同じ定義の変数は書き換えられていることが確認できました。

この処理がプログラムの意味を変えないために、
1個のセミコロンで区切った文の中で、
連続のLet句に限って実装することが必要だと思います。

違うときは、値のペアを保存するHashtableをクリアしないといけないです。
