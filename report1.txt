問１
Typing.fは型検査する関数なので、
その中で受けた字句解析の結果を検査する前に、
プリントアウト用の自作関数を適用するようにしました。

let f e =
  extenv := M.empty;
  (try unify Type.Unit (g M.empty e)
  with Unify _ -> failwith "top level does not have type unit");
  show_syntax_tree "  " e; (* 自作関数 *)
  extenv := M.map deref_typ !extenv;
  deref_term e

字句解析の結果の型によって、
複数のTyping.tを含めて、
それを順番に出力する必要があるので、
show_syntax_treesとshow_syntax_treeをまとめて定義しました。

let rec show_syntax_trees indent list =
  match list with
  | [] -> ()
  | t::ys -> show_syntax_tree indent t; show_syntax_trees indent ys
and show_syntax_tree indent e =
  match e with
  | Unit -> print_string (indent ^ "UNIT\n")
  | Bool(b) -> print_string (indent ^ "BOOL "); Printf.printf "%B\n" (b)
  | Int(i) -> print_string (indent ^ "INT "); Printf.printf "%i\n" (i)
  | Float(f) -> print_string (indent ^ "FLOAT "); Printf.printf "%F\n" (f)
  ......

テストファイルはtarget.mlです。
実行結果は以下です。

  LETREC fibn =
    IF
      LE
        VAR n
        INT 1
    THEN
      VAR n
    ELSE
      ADD
        APP
        VAR fib
          SUB
            VAR n
            INT 1
        APP
        VAR fib
          SUB
            VAR n
            INT 2
  IN
    APP
    VAR print_int
      APP
      VAR fib
        INT 30

問2
パースエラーの時に、問題が発生したところの行の番号とその行においての具体的な場所を出力させました。

まずはlexer.mllに、spaceから改行を除いてから以下を挿入しました。
| "\n"
    { Lexing.new_line lexbuf;
      token lexbuf }

そして、parse.mlyにエラーが発生するときに、その場所を出力するロジックを書きました。

let rec fib n =
  if n <= 1 then n else
  else
  fib (n-1) + fib (n-2)
in
  print_int fib 30

上のコードに対して、ちゃんと問題発生する場所を教えました。

Fatal error: exception Failure("Parse error at line 3 character 2")
